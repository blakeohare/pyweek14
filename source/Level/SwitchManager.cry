
function override_switch_behavior(manager, level, index, is_blue) {
	enabled = manager.enabled;
	name = level.name;
	
	if (name == '5-0') {
		if (index > 0) {
			if (enabled[1] && enabled[2]) {
				level.activate_switch('door', True);
			} else {
				level.activate_switch('door', False);
			}
			
			return True;
		}
	} else if (name == '16-0') {
		if (index == 0) {
			// Don't confuse the meaning of these 0's.
			// The index == 0 which is the switch ID
			// The pause token is 0 which is the moving platform ID
			// They're the same here because that's a coincidence
			level.moving_platforms.set_pause_token('0', !enabled[index]);
			return True;
		}
	} else if (name == '18-0') {
		mapping = [
			[10],
			[0],
			[2],
			[4],
			[1, 9],
			[5],
			[7],
			[8],
			[3, 6]
		];
		for (platform : mapping[index]) {
			level.moving_platforms.set_pause_token(str(platform), !enabled[index]);
		}
		return True;
	} else if (name == 'flipmaze') {
		level.activate_switch('blue', is_blue);
		return True;
	} else if (name == '24-0') {
		if (index == 4) {
			level.moving_platforms.set_pause_token('2', !enabled[index]);
			return True;
		}
	} else if (name == '25-0') {
		level.moving_platforms.set_pause_token(str(index - 1), !enabled[index]);
		if (index != 0) {
		
			return True;
		}
	} else if (name == '90-0') {
		if (index == 0) {
			level.moving_platforms.set_pause_token('0', !enabled[index]);
			return True;
		}
	}
	return False;
}

class SwitchManager {

	static field _switch_mapping = {
		'4-0': [
			'blue'
		],
		
		'5-0': [
			'bridge',
			None,
			None
		],
		
		'8-0': [
			'exit'
		],
		
		'9-0': [
			'exit'
		],
		
		'10-2': [
			'bridgene',
			'bridgenw',
			'bridgese'
		],
		
		'12-0': [
			'exit'
		],
		
		'14-0': [
			'blue',
			'exit'
		],
		
		'16-0': [
			None,
			'green'
		],
		
		'17-3': [
			'red',
			'blue'
		],
		
		'18-0': [None] * 9,
		
		'19-0': [
			'power'
		],
		
		'19c-0':
		[ 'button' ],
		
		'20-0': [
			'blue',
			'power'
		],
		
		'21-0': [
			'green',
			'blue',
			'powere',
			'powerw'
		],
		
		'21a-0': [
			'green',
			'magenta',
			'yellow',
			'cyan'
		],
		
		'24-0': [
			'green',
			'power',
			'purple',
			'grey',
			None,
			'yellow'
		],
		
		'25-0': [
			'grey'
		],
		
		'26-0': [
			'blue',
			'red'
		],
		
		'27-0': [
			'cyan',
			'magenta',
			'yellow'
		],
		
		'28-0': [
			'door',
			'bridge'
		],
		
		'90-0': [
			None,
			'green',
			'blue',
			'power',
			'power',
			'yellow'
		]
	};

	constructor(level, playscene) {
		self.playscene = playscene;
		self.level = level;
		self.flipmaze_hack = playscene.story_mode && level.name == 'flipmaze';
		self.switches = self.level.get_switches();
		self.enabled = [False] * len(self.switches);
		self.statuses = [None] * len(self.switches);
		self.locations = {};
		for (_switch : self.switches) {
			k = _switch[0] + '^' + _switch[1];
			self.locations[k] = self.locations.get(k, []);
			self.locations[k].add(_switch);
		}
		
		ts = get_tile_store();
		self.rubiks = ts.get_tile('rubiks');
		self.colors = {
			// Switch, block
			'gray': [ts.get_tile('b1'), ts.get_tile('3')],
			'red': [ts.get_tile('b2'), ts.get_tile('9')],
			'blue': [ts.get_tile('b4'), ts.get_tile('10')],
			'green': [ts.get_tile('b3'), ts.get_tile('11')],
			'magenta': [ts.get_tile('b6'), ts.get_tile('12')],
			'cyan': [ts.get_tile('b5'), ts.get_tile('13')],
			'yellow': [ts.get_tile('b7'), ts.get_tile('14')],
			'battery': [ts.get_tile('pi'), ts.get_tile('45')],
		};
		
		self.activator_lookup = {};
		for (color : self.colors.keys()) {
			self.activator_lookup[self.colors[color][0].id] = self.colors[color][1];
		}
	}
	
	function update_statuses_for_sprite(sprite, level) {
		col = Math.floor(sprite.x / 16);
		row = Math.floor(sprite.y / 16);
		layer = Math.floor(sprite.z / 8) - 1;
		
		floor = level.get_tile_at(col, row, layer);
		if (floor != None && floor.isswitch) {
			i = 0;
			while (i < len(self.switches)) {
				sw = self.switches[i];
				
				if (sw[0] == col && sw[1] == row && sw[2] == layer) {
					self.statuses[i] = ['sprite', sprite];
					break;
				}
				i += 1;
			}
		}
	}
	
	function check_switch_for_block_and_update(i, _switch, level) {
		col = _switch[0];
		row = _switch[1];
		layer = _switch[2] + 1;
		above = level.get_tile_at(col, row, layer);
		if (above != None && above.pushable) {
			self.statuses[i] = ['block', above];
		}
	}
		
	function update_statuses(sprites) {
		if (len(self.switches) == 0) {
			return;
		}
		
		i = 0;
		while (i < len(self.switches)) {
			self.statuses[i] = None;
			i += 1;
		}
		
		players = [];
		level = self.level;
		for (sprite : sprites) {
			if (sprite.main_or_hologram) {
				players.add(sprite);
			} else {
				self.update_statuses_for_sprite(sprite, level);
			}
		}
		
		for (p : players) {
			self.update_statuses_for_sprite(p, level);
		}
		
		i = 0;
		while (i < len(self.switches)) {
			self.check_switch_for_block_and_update(i, self.switches[i], level);
			i += 1;
		}
	}
	
	function update_enabled(sprites, suppress_triggers) {
		
		self.update_statuses(sprites);
		before = self.enabled.clone();
		
		i = 0;
		while (i < len(self.switches)) {
			_switch = self.switches[i];
			status = self.statuses[i];
			if (status != None) {
				if (status[0] == 'sprite') {
					if (_switch[3] == self.colors['gray'][0] || self.level.name == 'flipmaze') {
						if (self.flipmaze_hack) {
							self.flipmaze_hack = False;
							self.playscene.next = new DialogScene(self.playscene, 'h1');
						}
						self.enabled[i] = True;
					}
				} else if (status[0] == 'block') {
					type = _switch[3];
					if (type == self.colors['gray'] || (status[1] == self.rubiks && type.id != 'pi')) {
						self.enabled[i] = True;
					} else if (self.activator_lookup[type.id] == status[1]) {
						self.enabled[i] = True;
					} else {
						self.enabled[i] = False;
					}
				}
			} else {
				self.enabled[i] = False;
			}
			
			if (!suppress_triggers) {
				if (before[i] != self.enabled[i]) {
					self.do_action(self.level, self.level.name, i, self.enabled[i]);
				}
			}
			
			i += 1;
		}
	}
	
	function do_action(level, name, switch_index, positive) {
		
		is_blue = level.get_tile_at(self.switches[switch_index]) == self.colors['blue'][0];
		
		if (override_switch_behavior(self, level, switch_index, is_blue)) {
			return;
		}
		
		mapping = SwitchManager._switch_mapping.get(name);
		if (mapping != None) {
			action_name = mapping[switch_index];
			level.activate_switch(action_name, positive);
		}
	}
}
