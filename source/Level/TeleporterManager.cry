class TeleporterManager {
	constructor(level) {
		self.level = level;
		transporters = level.get_teleporters();
		self.counter = 0;
		senders = [];
		receivers = [];
		enabled = [];
		in_use = [];
		for (t : transporters) {
			if (t[3] == 't1' || t[3] == 't3') {
				senders.add(t);
				enabled.add(t[3] == 't1');
			} else {
				receivers.add(t);
			}
		}
		
		self.senders = senders;
		self.receivers = receivers;
		
		self.manual_level_config(level.name);

		self.new_sprites = {};
		self.remove_sprites = [];
		self.in_use = len(self.senders) * [999];
		self.enabled = enabled;
	}

	function manual_level_config(name) {
		if (name == '13-0') {
			r = self.receivers;
			self.receivers = [
				r[0], r[9], r[4], r[5], r[2], r[10], r[3], r[1], r[8], r[6], r[7]
			];
		}
	}
	
	function set_teleporter_status(col, row, layer, isenabled) {
		i = 0;
		total = len(self.senders);
		while (i < total) {
			sender = self.senders[i];
			if (sender[0] == col && sender[1] == row && sender[2] == layer) {
				enabled[i] = isenabled;
				self.update_tiles(i);
				return;
			}
			receiver = self.receivers[i];
			if (receiver[0] == col && receiver[1] == row && receiver[2] == layer) {
				enabled[i] = isenabled;
				self.update_tiles(i);
				return;
			}
		}
	}
	
	function enable_teleporter(col, row, layer) {
		self.set_teleporter_status(col, row, layer, True);
	}
	
	function disable_teleporter(col, row, layer) {
		self.set_teleporter_status(col, row, layer, False);
	}
	
	function update_tiles(index) {
		sender = self.senders[index];
		receiver = self.receivers[index];
		level = self.level;;
		ts = get_tile_store();
		s_tile = ts.get_tile('t1');
		r_tile = ts.get_tile('t2');
		if (!self.enabled[index]) {
			s_tile = ts.get_tile('t3');
			r_tile = ts.get_tile('t3');
		}
		level.modify_block(sender[0], sender[1], sender[2], s_tile);
		level.modify_block(receiver[0], receiver[1], receiver[2], r_tile);
	}
	
	function get_destination(col, row, layer) {
		final = self.get_sender([col, row, layer]);
		if (final != None && self.enabled[final]) {
			output = self.receivers[final];
			for (i : py_range(4)) {
				z = output[2] + i + 1;
				tile = self.level.get_tile_at(output[0], output[1], z);
				if (tile != None && tile.blocking) {
					return 'blocked';
				}
			}
			if (self.in_use[final] < 200) {
				return None;
			}
			self.in_use[final] = 0;
			return output;
		}
		return None;
	}
	
	function teleport_block(blocktype, source, target) {
		sprite = new Sprite(source[0] * 16 + 8, source[1] * 16 + 8, source[2] * 8, 'block|' + blocktype.id);
		self.teleport_sprite(sprite, target);
	}
	
	function teleport_sprite(sprite, target) {
		play_sound('teleport');
		sprite.immobilized = True;
		self.remove_sprites.add(sprite);
		
		self.new_sprites[self.counter + 1] = self.new_sprites.get(self.counter + 1, []);
		self.new_sprites[self.counter + 1].add(new Sprite(sprite.x, sprite.y, sprite.z, 'teleport|' + sprite.type));
		
		self.new_sprites[self.counter + 120] = self.new_sprites.get(self.counter + 120, []);
		z = (target[2] + 1) * 8;
		clone = new Sprite(target[0] * 16 + 8, target[1] * 16 + 8, z, 'receiving|' + sprite.type);
		clone.standingon = get_tile_store().get_tile('t2');
		clone.prototype = sprite;
		
		self.new_sprites[self.counter + 120].add(clone);
	}
	
	function tag_as_in_use(coords) {
		sender_index = self.get_sender(coords);
		if (sender_index != None) {
			self.in_use[sender_index] = 0;
		}
	}
	
	function is_in_use(i) {
		return self.in_use[i] <= 90;
	}
	
	function get_sender(coords) {
		i = 0;
		while (i < len(self.senders)) {
			s = self.senders[i];
			if (s[0] == coords[0] && s[1] == coords[1] && s[2] == coords[2]) {
				return i;
			}
			i += 1;
		}
		return None;
	}
	
	function get_new_sprites() {
		new_sprites = self.new_sprites.get(self.counter, None);
		if (new_sprites == None) {
			return [];
		}
		return self.new_sprites.pop(self.counter);
	}
	
	function get_removed_sprites() {
		output = self.remove_sprites;
		self.remove_sprites = [];
		return output;
	}
	
	function update() {
		self.counter += 1;
		i = 0;
		while (i < len(self.in_use)) {
			self.in_use[i] += 1;
			i += 1;
		}
	}
}
